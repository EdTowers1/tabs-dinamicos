function api_home_cilindros( oDom )

    do case
        case oDom:GetProc() == 'ayuda_cliente'								; DoAyudaCliente( oDom )
        case oDom:GetProc() == 'ayuda_cilindro'								; DoAyudaCilindro( oDom )
        case oDom:GetProc() == 'seleccionar_cliente'						; DoSelecionar_Cliente(oDom)
        case oDom:GetProc() == 'exe_consulta'       				        ; DoExeConsulta(oDom)
        case oDom:GetProc() == 'nav_refresh'								; DoNav_Refresh( oDom )
        case oDom:GetProc() == 'nav_top'									; DoNav_Top( oDom )
        case oDom:GetProc() == 'nav_prev'									; DoNav_Prev( oDom )
        case oDom:GetProc() == 'nav_next'									; DoNav_Next( oDom )
        case oDom:GetProc() == 'nav_end'									; DoNav_End( oDom )
        case oDom:GetProc() == 'sincronizar'								; DoSincronizar( oDom )
        case oDom:GetProc() == 'filtrar_movimiento'						    ; DoFiltrarMovimiento( oDom )
        case oDom:GetProc() == 'agregar_cilindro'          				    ; DoAgregarCilindro(oDom)
        case oDom:GetProc() == 'actualizar_movimiento'			    ; DoActualizarMovimiento(oDom)
            otherwise 				
            oDom:SetError( "Proc don't defined => " + oDom:GetProc())
    endcase
	
retu oDom:Send()

// -------------------------------------------------- //

static function DoAyudaCliente( oDom )

    local cHtml := ULoadHtml( '../html/ayudas/ayuda_cliente.html'  )
    local o    := {=>}    

    o[ 'title' ]           := 'Ayuda de clientes'
    o[ 'centerVertical' ]  := .T.
    o[ 'draggable' ]       := .f.
    o[ 'focus']            := 'dlg_clientes-cFiltro'
    o[ 'width' ]           := 800
    

    oDom:SetDialog( 'ayuda_cliente', cHtml, nil, o )

retu nil

// -------------------------------------------------- //

static function DoAyudaCilindro( oDom )

    local cHtml := ULoadHtml( '../html/ayudas/ayuda_cilindro.html'  )
    local o    := {=>}    

    o[ 'title' ]           := 'Nuevo Cilindro'
    o[ 'centerVertical' ]  := .T.
    o[ 'draggable' ]       := .f.
    o[ 'width' ]           := 800
    

    oDom:SetDialog( 'ayuda_cilindros', cHtml, nil, o )

retu nil

// -------------------------------------------------- //


static function DoSelecionar_Cliente(oDom)
    local cCodCli := AllTrim(oDom:Get('cCliente'))
    local oQry, hFull, cInfoCliente := ""
    local hInfo := InitInfo(oDom)
    local lConnected := .f.

    oDom:Set('cInfoCliente', "")

    // Validar código de cliente
    if hb_isNil(cCodCli) .or. empty(cCodCli)
        oDom:Set('cCliente', "")
        oDom:SetAlert("Debe ingresar el código del cliente.")
        oDom:focus('cCliente')
        return nil
    endif

    // Abrir conexión
    lConnected := OpenConnect(oDom, hInfo)
    if !lConnected
        oDom:SetError("No se pudo conectar a la base de datos.")
        return nil
    endif

    // Consultar cliente
    oQry := hInfo['db']:Query("SELECT * FROM m_terceros WHERE codcli = '" + cCodCli + "'")
    if oQry == NIL .or. oQry:reccount() == 0
        oDom:SetAlert("No se encontró el cliente con código: " + cCodCli, "Error")
        oDom:Set('cCliente', "")
        oDom:focus('cCliente')
        CloseConnect(oDom, hInfo)
        return nil
    endif

    hFull := oQry:FillHRow()
    cInfoCliente := "Código: " + hFull['codcli'] + CHR(13) + CHR(10) + ;
        "Nombre: " + hb_strtoutf8(hFull['nombre_tercero']) + CHR(13) + CHR(10)

    oDom:setDlg('home_cilindros')
    oDom:Set('cInfoCliente', cInfoCliente)
    
    // oDom:focus('cOrden')
    CloseConnect(oDom, hInfo)

return nil

// -------------------------------------------------- //

static function DoExeConsulta( oDom )
    local hInfo := InitInfo( oDom )

    // Abrir base de datos
    IF ! OpenConnect(oDom, hInfo)
        return .f.
    endif

    // Obtener total de registros
    if ! TotalRows( oDom, hInfo )
        CloseConnect( oDom, hInfo )
    endif

    // Cargar datos de la primera página
    LoadRows( oDom, hInfo, .T. )  // .T. = inicializar browse

    // Cerrar conexión
    CloseConnect( oDom, hInfo )

    // Actualizar controles DOM
    Refresh_Nav( oDom, hInfo )

return .t.

// -------------------------------------------------- //
static function DoNav_Next( oDom )

    local hInfo	:= InitInfo( oDom )

    //	Open Database
    if ! OpenConnect( oDom, hInfo )
        return nil
    endif

    //	Refresh Total rows
    if ! TotalRows( oDom, hInfo )
        return nil
    endif

    //	Update page
    hInfo[ 'page' ]++

    if hInfo[ 'page' ] > hInfo[ 'page_total' ]
        hInfo[ 'page' ] := hInfo[ 'page_total' ]
    endif

    //	Load data...
    LoadRows( oDom, hInfo )

    //	Close database connection
    CloseConnect( oDom, hInfo )

    //	Refresh Dom
    Refresh_Nav( oDom, hInfo )

return nil

// -------------------------------------------------- //

static function TotalRows( oDom, hInfo )
    local oQry, nTotal := 0
    local cSql, cWhere := ""

    hInfo[ 'total' ] := 0

    // Construir cláusula WHERE para filtro general (buscar por número de documento o nombre del cliente)
    if !empty(hInfo['filtro'])
        cWhere := "(UPPER(t1.docto) LIKE '%" + Upper(hInfo['filtro']) + "%' OR UPPER(t2.nombre_tercero) LIKE '%" + Upper(hInfo['filtro']) + "%')"
    endif

    // Construir SQL con filtros (incluye JOIN para poder filtrar por nombre de tercero)
    cSql := "SELECT COUNT(*) as total FROM m_docto_header t1 LEFT JOIN m_terceros t2 ON t1.codcli = t2.codcli"
    if !empty(cWhere)
        cSql += " WHERE " + cWhere
    endif

    // Consulta para obtener el total de registros
    oQry := hInfo[ 'db' ]:Query( cSql )

    IF oQry != NIL
        nTotal := oQry:total
        hInfo[ 'total' ] := nTotal
    ELSE
        oDom:SetError( 'Error counting records' )
        return .f.
    ENDIF

    // Calcular total de páginas
    hInfo[ 'page_total' ] := Int( hInfo[ 'total' ] / hInfo[ 'page_rows' ] ) + ;
        if( hInfo[ 'total' ] % hInfo[ 'page_rows' ] == 0, 0, 1 )

    // Validar página actual
    if hInfo[ 'page' ] > hInfo[ 'page_total' ] .or. hInfo[ 'page' ] <= 0
        hInfo[ 'page' ] := 1
    endif

return .t.

// -------------------------------------------------- //

static function LoadRows( oDom, hInfo, lInitBrw )
    local oQry, aMovimientos := {}, aRow := {}
    local cSql, cWhere := "", nRowInit

    hb_default( @lInitBrw, .f. )

    if !empty(hInfo['filtro'])
        cWhere := "(UPPER(t1.docto) LIKE '%" + Upper(hInfo['filtro']) + "%' OR UPPER(t2.nombre_tercero) LIKE '%" + Upper(hInfo['filtro']) + "%')"
    endif

    // Calcular OFFSET para la paginación
    nRowInit := ( hInfo[ 'page' ] - 1 ) * hInfo[ 'page_rows']

    // Construir SQL con LIMIT, OFFSET y WHERE para filtros
    cSql := "SELECT t1.row_id, t1.docto, t1.fecha, t1.codcli, t2.nombre_tercero " + ;
        "FROM m_docto_header t1 " + ;
        "LEFT JOIN m_terceros t2 ON t1.codcli = t2.codcli"

    if !empty(cWhere)
        cSql += " WHERE " + cWhere
    endif

    cSql += " ORDER BY t1.docto DESC "

    cSql += " LIMIT " + ltrim(str(hInfo[ 'page_rows' ])) + " OFFSET " + ltrim(str(nRowInit))

    oQry := hInfo[ 'db' ]:Query( cSql )

    IF oQry != NIL
        oQry:gotop()
        DO WHILE ! oQry:Eof()
            aRow := { 'ROW_ID' => oQry:row_id, 'DOCTO' => oQry:docto, 'FECHA' => dtoc( oQry:fecha ), 'NOMCLI' => hb_strtoutf8(oQry:nombre_tercero) }
            AADD( aMovimientos, aRow )
            oQry:Skip()
        END
    ELSE
        oDom:SetError( 'Error loading data' )
        return .f.
    ENDIF

    // Actualizar tabla
    oDom:TableSetData( 'movimientos', aMovimientos )

return .t.

// -------------------------------------------------- //

static function Refresh_Nav( oDom, hInfo )
    oDom:Set    ( 'nav_total'		, hInfo[ 'total' ] )
    oDom:Set( 'nav_page'		, ltrim(str(hInfo[ 'page' ])) )
    oDom:Set( 'nav_page_rows'	, ltrim(str(hInfo[ 'page_rows' ])) )
    oDom:Set( 'nav_page_total'	, ltrim(str(hInfo[ 'page_total' ])) )
return nil

// -------------------------------------------------- //

static function DoNav_Top( oDom )
    local hInfo	:= InitInfo( oDom )

    // Abrir base de datos
    if ! OpenConnect( oDom, hInfo )
        return nil
    endif

    // Obtener total de registros
    if ! TotalRows( oDom, hInfo )
        return nil
    endif

    // Ir a primera página
    hInfo[ 'page' ] := 1

    // Cargar datos
    LoadRows( oDom, hInfo )

    // Cerrar conexión
    CloseConnect( oDom, hInfo )

    // Actualizar controles DOM
    Refresh_Nav( oDom, hInfo )

return nil

// -------------------------------------------------- //

static function DoNav_End( oDom )
    local hInfo	:= InitInfo( oDom )

    // Abrir base de datos
    if ! OpenConnect( oDom, hInfo )
        return nil
    endif

    // Obtener total de registros
    if ! TotalRows( oDom, hInfo )
        return nil
    endif

    // Ir a última página
    hInfo[ 'page' ] := hInfo[ 'page_total' ]

    // Cargar datos
    LoadRows( oDom, hInfo )

    // Cerrar conexión
    CloseConnect( oDom, hInfo )

    // Actualizar controles DOM
    Refresh_Nav( oDom, hInfo )

return nil

// -------------------------------------------------- //

static function DoNav_Prev( oDom )
    local hInfo	:= InitInfo( oDom )

    // Abrir base de datos
    if ! OpenConnect( oDom, hInfo )
        return nil
    endif

    // Obtener total de registros
    if ! TotalRows( oDom, hInfo )
        return nil
    endif

    // Ir a página anterior
    hInfo[ 'page' ]--

    if hInfo[ 'page' ] <= 0
        hInfo[ 'page' ] := 1
    endif

    // Cargar datos
    LoadRows( oDom, hInfo )

    // Cerrar conexión
    CloseConnect( oDom, hInfo )

    // Actualizar controles DOM
    Refresh_Nav( oDom, hInfo )

return nil

// -------------------------------------------------- //

static function DoNav_Refresh( oDom, hInfo )

    // Inicializar información si no se proporciona
    if hInfo == NIL
        hInfo := InitInfo( oDom )
    endif

    // Abrir base de datos
    if ! OpenConnect( oDom, hInfo )
        return nil
    endif

    // Obtener total de registros
    if ! TotalRows( oDom, hInfo )
        return nil
    endif

    // Cargar datos
    LoadRows( oDom, hInfo )

    // Actualizar controles DOM
    Refresh_Nav( oDom, hInfo )

    // Cerrar conexión
    CloseConnect( oDom, hInfo )

return nil

// -------------------------------------------------- //


static function DoSincronizar(oDom) 
    local cCodigo := ''
    local cDlg := 'home_cilindros'
    local oRow
    local hInfo
    local lConnected := .f.
    local cSql
    local oQry, hFull, cInfoCliente := ""
    local aCilindros := {}
    local aRow := {}

    oRow := oDom:Get( cDlg + '-row' )
    hInfo := InitInfo(oDom)


    if hb_isNil( oRow ) .or. empty( oRow )
        oRow := oDom:Get( 'row' )
    endif
    if hb_isObject( oRow ) .and. ! hb_isNil( oRow['value'] )
        oRow := oRow['value']
    endif

    cCodigo := oRow['DOCTO']

    if ValType( oRow ) $ 'AOH'
        cCodigo := AllTrim( iif( !hb_isNil( oRow['DOCTO'] ), oRow['DOCTO'], iif( !hb_isNil( oRow['docto'] ), oRow['docto'], '' ) ) )
    endif

    // Abrir conexión
    lConnected := OpenConnect(oDom, hInfo)
    if !lConnected
        oDom:SetError("No se pudo conectar a la base de datos.")
        return nil
    endif

    // Consultar encabezado y cuerpo del documento con JOIN y filtro por docto
    cSql := "SELECT h.docto, h.fecha, h.codcli, t.nombre_tercero, " + ;
        "b.codigo_articulo, b.cantidad, b.precio_docto " + ;
        "FROM m_docto_header h " + ;
        "LEFT JOIN m_terceros t ON h.codcli = t.codcli " + ;
        "LEFT JOIN m_docto_body b ON h.docto = b.docto " + ;
        "WHERE h.docto = " + cCodigo + " " + ;
        "ORDER BY b.codigo_articulo"

    oQry := hInfo['db']:Query( cSql, cCodigo )

    if oQry != NIL .and. !oQry:eof()
        hFull := oQry:FillHRow()

        cInfoCliente := "Código: " + hFull['codcli'] + CHR(13) + CHR(10) + ;
            "Nombre: " + hb_strtoutf8(hFull['nombre_tercero'])

        oDom:Set('cOrden', cCodigo)
        oDom:Set('cFecha', Str(Year(hFull['fecha']), 4) + "-" + StrZero(Month(hFull['fecha']), 2) + "-" + StrZero(Day(hFull['fecha']), 2))
        oDom:Set('cInfoCliente', cInfoCliente)

        // Llenar tabla de cilindros con los datos del cuerpo del documento
        
        oQry:gotop()
        DO WHILE ! oQry:Eof()
            if !hb_isNil(oQry:codigo_articulo) .and. !empty(oQry:codigo_articulo)
                aRow := { 'CODIGO' => oQry:codigo_articulo, 'CANTIDAD' => oQry:cantidad, 'PRECIO' => oQry:precio_docto }
                AADD( aCilindros, aRow )
            endif
            oQry:Skip()
        ENDDO

        // Actualizar tabla de cilindros
        oDom:TableSetData( 'cilindros', aCilindros )
    endif 

    CloseConnect(oDom, hInfo)

return nil


static function DoFiltrarMovimiento (oDom)

    local cFiltro := ""
    local hInfo := InitInfo( oDom )
    
    // Obtener el valor del filtro desde el DOM
    cFiltro := AllTrim(oDom:Get("cFiltroMovimiento"))

    // Abrir conexión a la base de datos
    if ! OpenConnect( oDom, hInfo )
        return oDom:Send()
    endif
    
    // Agregar filtro a la información
    if !Empty(cFiltro)
        hInfo[ 'filtro' ] := cFiltro
    else
        hInfo[ 'filtro' ] := ""
    endif
    
    // Resetear página a 1 cuando se aplica filtro
    hInfo[ 'page' ] := 1
    
    // Obtener total de registros con el filtro
    if ! TotalRows( oDom, hInfo )
        CloseConnect( oDom, hInfo )
        return oDom:Send()
    endif
    
    // Cargar datos filtrados
    if ! LoadRows( oDom, hInfo, .T. )
        CloseConnect( oDom, hInfo )
        return oDom:Send()
    endif
    
    // Cerrar conexión
    CloseConnect( oDom, hInfo )
    
    // Actualizar controles de navegación
    Refresh_Nav( oDom, hInfo )

return oDom:Send()

// -------------------------------------------------- //


static function DoAgregarCilindro(oDom)
    local cCodCil := AllTrim(oDom:Get('cNuevoCilindro'))
    local oQry, hFull
    local hInfo := InitInfo(oDom)
    local lConnected := .f.
    local aCilindros := {}
    local hCilindro := {=>}
    local cCilindrosJson
    local lExists := .F.
    local h, aRow := {}


    // validar código de cilindro
    if hb_isNil(cCodCil) .or. empty(cCodCil)
        oDom:Set('cNuevoCilindro', "")
        oDom:SetAlert("Debe ingresar el código del cilindro.")
        oDom:focus('cNuevoCilindro')
        return nil
    endif

    // Abrir conexión a la base de datos
    lConnected := OpenConnect(oDom, hInfo)
    if !lConnected
        oDom:SetError("No se pudo conectar a la base de datos.")
        return nil
    endif

    // consultar cilindro
    oQry := hInfo['db']:Query("SELECT * FROM tbcilindros WHERE cil_codigo = '" + cCodCil + "'")
    if oQry == NIL .or. oQry:reccount() == 0
        oDom:SetAlert("No se encontró el cilindro con código: " + cCodCil, "Error")
        oDom:Set('cNuevoCilindro', "")
        oDom:focus('cNuevoCilindro')
        CloseConnect(oDom, hInfo)
        return nil
    endif

    hFull := oQry:FillHRow()

    // Construir el hash del cilindro (ajusta los campos según tus columnas)
    hCilindro['CODIGO']  := hFull['cil_codigo']
    hCilindro['CANTIDAD']:= 1

    // Obtener los cilindros actuales de la tabla desde el campo oculto JSON
    cCilindrosJson := oDom:Get('cilindros_json')
    if !empty(cCilindrosJson)
        oDom:console("Cilindros JSON: " + cCilindrosJson)
        aCilindros := hb_jsonDecode(cCilindrosJson)

    else
        oDom:console("No hay cilindros actuales, inicializando array vacío.")
        aCilindros := {}
    endif

    // Verificar duplicado: si ya existe un cilindro con el mismo código, mostrar alerta y no agregar
    if ValType(aCilindros) $ 'A'

        for each h in aCilindros
            if !hb_isNil(h['CODIGO']) .and. AllTrim(Upper(h['CODIGO'])) == AllTrim(Upper(hCilindro['CODIGO']))
                lExists := .T.
                exit
            endif
        next
        if lExists
            // cerrar conexion antes de retornar
            oDom:SetAlert("El cilindro con código " + AllTrim(hCilindro['CODIGO']) + " ya está registrado.")
            oDom:Set('cNuevoCilindro', "")
            oDom:focus('cNuevoCilindro')
            CloseConnect(oDom, hInfo)
            return nil
        endif
    endif

    AAdd(aCilindros, hCilindro)

    // Actualizar la tabla de cilindros
    oDom:TableSetData('cilindros', aCilindros)

    oDom:Set('cNuevoCilindro', "")

    CloseConnect(oDom, hInfo)

return nil


// -------------------------------------------------- //

static function DoActualizarMovimiento(oDom, hInfo)

    local cDlg := 'home_cilindros', cDocto := '', cCodCli := ''
    local oQry, aCilindros := {}, hCil, cCilJson := "", cCodigo := "", oChk, cSql
    local oRow
    hb_default( @hInfo, NIL )

    if hInfo == NIL
        hInfo := InitInfo( oDom )
    endif

    // Obtener número de documento y cliente desde el DOM
    cDocto := AllTrim( oDom:Get( 'cOrden' ) )
    cCodCli := AllTrim( oDom:Get( 'cCliente' ) )

    // Validaciones simples
    if empty( cDocto )
        oDom:SetAlert( 'Seleccione un movimiento (docto) para actualizar.' )
        return nil
    endif
    if empty( cCodCli )
        oDom:SetAlert( 'Ingrese el código del cliente para actualizar.' )
        oDom:focus( 'cCliente' )
        return nil
    endif

    // Abrir conexión
    if ! OpenConnect( oDom, hInfo )
        oDom:SetError( 'No se pudo conectar a la base de datos.' )
        return nil
    endif

    // Escapar valores para SQL
    cDocto := StrTran( cDocto, "'", "''" )
    cCodCli := StrTran( cCodCli, "'", "''" )

    // Comprobar existencia del cliente
    oQry := hInfo['db']:Query( "SELECT 1 AS ok FROM m_terceros WHERE codcli = '" + cCodCli + "' LIMIT 1" )
    if oQry == NIL .or. oQry:reccount() == 0
        oDom:SetAlert( 'El código de cliente ' + cCodCli + ' no existe.' )
        CloseConnect( oDom, hInfo )
        return nil
    endif

    // Iniciar transacción y aplicar cambios
    BEGIN SEQUENCE
        hInfo['db']:SqlQuery( "START TRANSACTION" )

        // Actualizar encabezado
        hInfo['db']:SqlQuery( "UPDATE m_docto_header SET codcli = '" + cCodCli + "' WHERE docto = '" + cDocto + "'" )

        // Obtener lista de cilindros desde DOM: preferir JSON oculto, si no, intentar obtener tabla
        aCilindros := {}
        cCilJson := oDom:Get( 'cilindros_json' )
        if ! empty( cCilJson )
            aCilindros := hb_jsonDecode( cCilJson )
        else
            // intentar leer directamente el control 'cilindros' si el DOM lo provee
            aCilindros := oDom:Get( 'cilindros' )
        endif

        // Normalizar estructura: cada elemento debe contener 'CODIGO' / 'codigo' / 'codigo_articulo'
        if ValType( aCilindros ) $ 'A' .and. Len( aCilindros ) > 0
            for each hCil in aCilindros
                cCodigo := ''
                if ValType( hCil ) $ 'AOH'
                    if ! hb_isNil( hCil['CODIGO'] )
                        cCodigo := hCil['CODIGO']
                    elseif ! hb_isNil( hCil['codigo'] )
                        cCodigo := hCil['codigo']
                    elseif ! hb_isNil( hCil['codigo_articulo'] )
                        cCodigo := hCil['codigo_articulo']
                    endif
                elseif ValType( hCil ) == 'C'
                    cCodigo := hCil
                endif

                cCodigo := AllTrim( cCodigo )
                if empty( cCodigo )
                    continue
                endif

                // Escapar
                cCodigo := StrTran( cCodigo, "'", "''" )

                // Si no existe en el cuerpo, insertarlo
                oChk := hInfo['db']:Query( "SELECT 1 AS ok FROM m_docto_body WHERE docto = '" + cDocto + "' AND codigo_articulo = '" + cCodigo + "' LIMIT 1" )
                if oChk == NIL .or. oChk:reccount() == 0
                    cSql := "INSERT INTO m_docto_body (docto, codigo_articulo, cantidad, precio_docto) VALUES ('" + cDocto + "', '" + cCodigo + "', 1, 0)"
                    hInfo['db']:SqlQuery( cSql )
                endif
            next
        endif

        // Confirmar transacción
        hInfo['db']:SqlQuery( "COMMIT" )

        oDom:SetAlert( 'Cliente y cilindros (nuevos) actualizados correctamente para el movimiento ' + cDocto )
    RECOVER
        // Intentar deshacer cambios si hay fallo
        hInfo['db']:SqlQuery( "ROLLBACK" )
        oDom:SetError( 'Error actualizando movimiento.' )
        CloseConnect( oDom, hInfo )
        return nil
    END SEQUENCE

    // Cerrar conexión
    CloseConnect( oDom, hInfo )

    // Limpiar campos y refrescar UI
    oDom:Set( 'cCliente', "" )
    oDom:Set( 'cNuevoCilindro', "" )

    // Refrescar detalle y navegación
    DoSincronizar( oDom )
    DoNav_Refresh( oDom )

return nil